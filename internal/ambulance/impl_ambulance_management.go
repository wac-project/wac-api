/*
 * Hospital Management API
 *
 * API for managing hospital ambulances, procedures, and payments.
 *
 * API version: 1.0.0
 * Contact: xkokavecs@stuba.sk
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

 package ambulance

 import (
	 "context"
	 "log"
	 "net/http"
	 "time"
 
	 "github.com/gin-gonic/gin"
	 "github.com/google/uuid"
	 "github.com/wac-project/wac-api/internal/db_service"
 )
 
 // implAmbulanceAPI implements the AmbulanceManagementAPI interface using the standard DbService interface.
 type implAmbulanceAPI struct{}
 
 // NewAmbulanceAPI returns an implementation of AmbulanceManagementAPI using context-injected DbService.
 func NewAmbulanceAPI() AmbulanceManagementAPI {
	 return &implAmbulanceAPI{}
 }
 
 func getDB(c *gin.Context) db_service.DbService[Ambulance] {
	 return c.MustGet("db_service_ambulance").(db_service.DbService[Ambulance])
 }
 
 func withAmbulanceByID(c *gin.Context, fn func(c *gin.Context, ambulance *Ambulance) (*Ambulance, interface{}, int)) {
	 ambulanceId := c.Param("ambulanceId")
	 if ambulanceId == "" {
		 c.JSON(http.StatusBadRequest, gin.H{"status": http.StatusBadRequest, "message": "Ambulance ID is required"})
		 return
	 }
 
	 db := getDB(c)
	 ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	 defer cancel()
 
	 ambulance, err := db.FindDocument(ctx, ambulanceId)
	 if err != nil {
		 if err == db_service.ErrNotFound {
			 c.JSON(http.StatusNotFound, gin.H{"status": http.StatusNotFound, "message": "Ambulance not found"})
		 } else {
			 log.Println("FindDocument error:", err)
			 c.JSON(http.StatusInternalServerError, gin.H{"status": http.StatusInternalServerError, "message": "Internal error"})
		 }
		 return
	 }
 
	 updatedAmbulance, result, statusCode := fn(c, ambulance)
	 if updatedAmbulance != nil {
		 err := db.UpdateDocument(ctx, ambulanceId, updatedAmbulance)
		 if err != nil {
			 log.Println("UpdateDocument error:", err)
			 c.JSON(http.StatusInternalServerError, gin.H{"status": http.StatusInternalServerError, "message": "Failed to update ambulance"})
			 return
		 }
	 }
	 c.JSON(statusCode, result)
 }
 
 func (o *implAmbulanceAPI) CreateAmbulance(c *gin.Context) {
	 var ambulance Ambulance
	 if err := c.ShouldBindJSON(&ambulance); err != nil {
		 c.JSON(http.StatusBadRequest, gin.H{"message": "Invalid request body", "error": err.Error()})
		 return
	 }
	 if ambulance.Id == "" {
		 ambulance.Id = uuid.NewString()
	 }
 
	 db := getDB(c)
	 ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	 defer cancel()
 
	 err := db.CreateDocument(ctx, ambulance.Id, &ambulance)
	 if err != nil {
		 if err == db_service.ErrConflict {
			 c.JSON(http.StatusConflict, gin.H{"message": "Ambulance with this ID already exists"})
		 } else {
			 log.Println("CreateDocument error:", err)
			 c.JSON(http.StatusInternalServerError, gin.H{"message": "Failed to create ambulance"})
		 }
		 return
	 }
 
	 c.JSON(http.StatusCreated, ambulance)
 }
 
 func (o *implAmbulanceAPI) DeleteAmbulance(c *gin.Context) {
	 withAmbulanceByID(c, func(c *gin.Context, ambulance *Ambulance) (*Ambulance, interface{}, int) {
		 db := getDB(c)
		 ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		 defer cancel()
 
		 err := db.DeleteDocument(ctx, ambulance.Id)
		 if err != nil {
			 log.Println("DeleteDocument error:", err)
			 return nil, gin.H{"message": "Failed to delete ambulance"}, http.StatusInternalServerError
		 }
		 return nil, nil, http.StatusNoContent
	 })
 }
 
 func (o *implAmbulanceAPI) GetAmbulanceById(c *gin.Context) {
	 withAmbulanceByID(c, func(c *gin.Context, ambulance *Ambulance) (*Ambulance, interface{}, int) {
		 return nil, ambulance, http.StatusOK
	 })
 }
 
 func (o *implAmbulanceAPI) GetAmbulances(c *gin.Context) {
    db := getDB(c)
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    list, err := db.ListDocuments(ctx)
    if err != nil {
        log.Println("ListDocuments error:", err)
        c.JSON(http.StatusInternalServerError, gin.H{"message": "Failed to list ambulances"})
        return
    }
    c.JSON(http.StatusOK, list)
}

 
 func (o *implAmbulanceAPI) UpdateAmbulance(c *gin.Context) {
	 withAmbulanceByID(c, func(c *gin.Context, ambulance *Ambulance) (*Ambulance, interface{}, int) {
		 var updated Ambulance
		 if err := c.ShouldBindJSON(&updated); err != nil {
			 return nil, gin.H{"message": "Invalid request body", "error": err.Error()}, http.StatusBadRequest
		 }
 
		 if updated.Name != "" {
			 ambulance.Name = updated.Name
		 }
		 if updated.Location != "" {
			 ambulance.Location = updated.Location
		 }
		 if updated.Department != "" {
			 ambulance.Department = updated.Department
		 }
		 if updated.Capacity != 0 {
			 ambulance.Capacity = updated.Capacity
		 }
		 if updated.Status != "" {
			 ambulance.Status = updated.Status
		 }
 
		 return ambulance, ambulance, http.StatusOK
	 })
 }
 
 func (o *implAmbulanceAPI) GetAmbulanceSummary(c *gin.Context) {
	 withAmbulanceByID(c, func(c *gin.Context, ambulance *Ambulance) (*Ambulance, interface{}, int) {
		 summary := gin.H{
			 "ambulance_id": ambulance.Id,
			 "total_cost":   0.0, // Placeholder value
		 }
		 return nil, summary, http.StatusOK
	 })
 }

 // GetProceduresByAmbulance returns all procedures associated with a given ambulance.
func (o *implAmbulanceAPI) GetProceduresByAmbulance(c *gin.Context) {
    ambulanceID := c.Param("ambulanceId")
    if ambulanceID == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "ambulanceId is required"})
        return
    }

    // NOTE: replace the following stub with your actual DB/store call.
    // e.g. procedures, err := o.store.GetProceduresByAmbulanceID(ctx, ambulanceID)
    // For now, weâ€™ll return an empty slice.
    procedures := []Procedure{}

    c.JSON(http.StatusOK, procedures)
}

 